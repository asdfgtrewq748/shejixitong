模块一：路径规划算法改进（融入行业规程约束）

实现要点：当前主巷道路径规划较为简化，仅以最高分入口点到高分区中心作直线连接
GitHub
。我们需要引入煤矿规程约束——例如沿煤层走向布置（尽量沿煤层水平延伸以减少坡度）、避让障碍（避开已知断层、陷落柱等禁入区域）、预留煤柱宽度（确保巷道与工作面之间留有最小煤柱距离）以及坡度限制（巷道倾角不超出规定阈值）。为此，可采用基于网格的路径搜索算法（如 A*）取代固定三段直线方案。在算法中，将评分热力图视为权重网格：禁止进入障碍单元（将障碍对应网格权重设为无穷大或 Null），对低于最低评分的网格单元设高代价或直接视为不可通行，从而避免路径经过不适宜区域
GitHub
。在计算相邻网格移动成本时，引入坡度因素：若结合地质模型获取各网格的煤层高度，可计算相邻单元高差并换算坡度，超过阈值则该移动不可取（或赋极高代价）。此外，引入方向约束：沿煤层走向移动（与走向平行的方向）可赋予较低代价，而沿倾斜方向上山下山移动增大代价，以鼓励路径尽量沿走向展开。

**推荐代码结构/接口：*建议在后端新增独立的路径搜索模块或函数（例如 findOptimalPath(grid, start, goal, options)），其中 options 包含规程约束参数（如 maxSlope 最大坡度、pillarWidth 煤柱宽度、avoidAreas 障碍区域坐标等）。在生成主巷道时，先根据采区边界确定若干可能入口点（例如边界上若干离高分区较近的点），逐一以 A 搜索通往目标区域中心的最短可行路径，比较选择评分最高且满足约束的路径作为主巷道方案。
GitHub
GitHub
 若无任何路径满足要求，可调整约束（如稍微放宽坡度限制）或提示用户。为满足煤柱预留，可在路径生成后，通过检查路径与工作面的距离，若某段路径过于贴近工作面，则沿该工作面边缘平移路径或裁剪工作面尺寸以留出至少 pillarWidth 的间隔。针对分巷道规划，同样采用路径搜索：从主巷道接入点搜索至工作面连接点，避开工作面内部区域，且确保分巷道与工作面交接处保留煤柱（如将工作面边缘往内缩 pillarWidth 再作为连接点）。可将这些计算封装在 planMainRoadway 和 planBranchRoadways 中，使其调用通用的路径搜索函数并应用约束。接口上，可在前端 /api/design 请求体中增加参数，如 pillarWidth（煤柱宽度）和 maxSlope（坡度限制），供后端算法使用。

**代码片段：**下面示例展示了如何用伪代码实现改进的路径搜索，检查障碍与坡度约束，并计算路径：

function findOptimalPath(grid, start, goal, maxSlope, obstacles) {
  const openSet = new PriorityQueue();
  openSet.push({ cell: start, cost: 0 });
  const cameFrom = new Map();
  const costSoFar = new Map();
  costSoFar.set(start, 0);
  while (!openSet.isEmpty()) {
    const current = openSet.pop();  // 取出当前代价最小节点
    if (current.cell === goal) break;  // 抵达目标
    for (let neighbor of grid.getNeighbors(current.cell)) {
      if (!neighbor.insideBoundary || obstacles.has(neighbor) ) continue; // 避障
      // 坡度约束：计算 current 与 neighbor 高度差
      const dz = Math.abs(grid.heightAt(neighbor) - grid.heightAt(current.cell));
      const distance = grid.distance(current.cell, neighbor);
      const slope = dz / distance;
      if (slope > maxSlope) continue;  // 超坡度限制
      // 计算移动代价：基础距离，可加额外权重例如低评分区域
      let newCost = costSoFar.get(current.cell) + distance;
      if (grid.scoreAt(neighbor) < someScoreThreshold) {
        newCost += penalty;  // 低分区域惩罚
      }
      if (!costSoFar.has(neighbor) || newCost < costSoFar.get(neighbor)) {
        costSoFar.set(neighbor, newCost);
        const priority = newCost + heuristic(neighbor, goal);
        openSet.push({ cell: neighbor, cost: priority });
        cameFrom.set(neighbor, current.cell);
      }
    }
  }
  // 重建路径
  const path = [];
  let cur = goal;
  while (cur !== start) {
    path.unshift(cur);
    cur = cameFrom.get(cur);
  }
  path.unshift(start);
  return path;
}


上述伪代码体现了在栅格上进行路径搜索时对障碍物(obstacles)和坡度(slope)的判断。集成后，可在 planMainRoadway 中用 findOptimalPath 替代原来的直线路径生成，从而得到符合规程的最优巷道路径。主巷道生成后，继续按照设计流程调用 planWorkfaces 和 planBranchRoadways。需要注意，在 planBranchRoadways 中连接工作面时，也应考虑煤柱预留。比如当前直接连接到工作面边缘的实现
GitHub
应修改为：根据要求的煤柱宽度调整连接点的位置（如连接点距工作面实际边缘有一定偏移）。

模块二：巷道与工作面规划结果的数据结构设计

**实现要点：**为便于后续处理和前端展示，应采用清晰的数据结构来表达巷道（主巷道、分巷道）和工作面的几何布局。目前系统返回的设计结果包含主巷道路径、分巷道列表、工作面列表等
GitHub
。可以在此基础上做规范化和扩展：例如，引入 GeoJSON 格式或类似结构，将巷道表示为 LineString（线串）要素、工作面表示为 Polygon（多边形）要素，以标准坐标GeoJSON对象存储。同时保留现有简单表示，如使用对象数组，方便计算与渲染。无论采用哪种结构，关键是与评分热力图使用同一坐标系（如统一以米为单位的采区平面坐标），这样才能直接将设计结果叠加在热力图网格上无误差
GitHub
。此外需包含必要的属性：例如巷道对象应有长度、宽度、类型（主/副）等属性，工作面对象应有宽度、高度（长度）、朝向（走向方向）等，以便据此计算煤柱和通风要求等。

**推荐代码结构/接口：**建议在后端 store.design 中，使用分模块的嵌套结构：

store.design = {
  roadways: [
    { id: 'MR-01', type: 'main', path: [ {x,y}, {x,y}, ... ], width: 4, length: 500 }, 
    { id: 'BR-01', type: 'branch', path: [ {x,y}, ... ], width: 4, length: 120, workfaceId: 'WF-01' },
    // ... 更多巷道
  ],
  workfaces: [
    { id: 'WF-01', corners: [ {x,y}, ... ], width: 150, length: 80, avgScore: 75.3, orientation: 0 }, 
    // ... 更多工作面
  ],
  regions: [ /* 高分区域元数据，如中心点坐标、面积等 */ ],
  params: { ... },  // 保存设计参数（包含pillarWidth等）
  score: { ... }    // 设计方案评分
};


如上，使用单一 roadways 列表包含主巷道和分巷道，通过 type 区分（或分开 mainRoadway 和 branchRoadways 也可）。每条巷道由若干折线节点 (path) 构成；工作面可以用四个拐点 (corners) 定义多边形，或简化用中心点+宽度长度+朝向来生成矩形。推荐存储为 局部平面坐标（例如以采区某原点为参考），与评分网格 minX, minY 对齐
GitHub
。在导出 JSON 报告或与GIS交互时，可在接口层将其转换为 GeoJSON 的 LineString/Polygon 结构，方便在其他平台加载。前端绘制时，可继续使用画布直接读这些坐标绘制图形
GitHub
。如果引入非轴对齐的工作面（如沿走向成一定角度），需扩展绘制逻辑：Canvas 可通过 ctx.save(); ctx.translate(); ctx.rotate(); 实现矩形旋转绘制，或者逐点绘制多边形路径以描出倾斜的工作面区域。接口方面，前端调用 /api/design 获得上述结构的数据后，可统一处理，例如将所有 roadways 遍历绘制线条，将 workfaces 绘制为填充多边形。目前前端代码中已对主巷道和分巷道分别绘制
GitHub
GitHub
，对工作面用填充矩形表示
GitHub
；调整数据结构后，可在绘制时根据类型判断，或直接生成GeoJSON在前端用现有地图库渲染。总之，数据结构设计应便于一一对应实际矿图要素，清晰表达拓扑关系（如某分巷道连接哪个工作面），同时易于与现有网格坐标体系融合。

**代码片段：**下面给出修改后工作面数据结构的示例，以及如何计算其坐标并嵌入评分网格：

// 根据中心点、尺寸和朝向角度计算矩形工作面的四个顶点坐标
function createWorkface(id, centerX, centerY, width, length, orientationDeg) {
  const rad = orientationDeg * Math.PI / 180;
  const cos = Math.cos(rad), sin = Math.sin(rad);
  const halfW = width / 2, halfL = length / 2;
  // 矩形四角相对中心的偏移量
  const corners = [
    { x: centerX - halfL*cos - halfW*sin, y: centerY - halfL*sin + halfW*cos },
    { x: centerX + halfL*cos - halfW*sin, y: centerY + halfL*sin + halfW*cos },
    { x: centerX + halfL*cos + halfW*sin, y: centerY + halfL*sin - halfW*cos },
    { x: centerX - halfL*cos + halfW*sin, y: centerY - halfL*sin - halfW*cos }
  ];
  return { id, corners, width, length, orientation: orientationDeg };
}
// 示例：创建沿30度走向的工作面
const wf = createWorkface('WF-01', 400, 300, 150, 80, 30);
design.workfaces.push(wf);


上述代码通过给定中心和朝向角，计算了工作面四角坐标，便于绘制倾斜矩形。如果评分网格以 minX,minY 为原点构建（例如左下角坐标），则需确保传入 centerX, centerY 已使用相同参考系。例如，可从高分区域中心获取坐标
GitHub
并用于工作面规划。通过这样的数据结构，巷道和工作面规划结果可以方便地嵌入现有评分热力图，在前端叠加显示并导出。

模块三：地质建模模块构建（钻孔数据 -> 煤层面）

实现要点：煤层赋存的地质模型将为规划提供重要依据，包括确定煤层走向倾向（方位）和倾角（坡度）、指导沿走向布置和坡度限值约束。实现地质建模需从钻孔数据中提取煤层顶板和底板标高、煤厚及倾斜方向信息。首先，需扩充数据输入：在现有钻孔CSV中加入煤层顶底板深度或标高字段（例如每个钻孔提供煤层顶板海拔或埋深、底板埋深等）。在后端，新建地质模型计算模块，例如 generateGeologyModel(boreholes)。该模块可采用插值算法将离散钻孔数据转化为连续煤层面网格：例如使用反距离权重法（IDW）或克里金法，根据各钻孔的顶板标高，计算得到采区范围内规则网格的顶板高程；底板高程则可由顶板减去煤厚得到。也可采用三角网 (TIN) 插值：对钻孔点进行 Delaunay 三角剖分，将每个三角面投影为煤层面的一部分，更精细地反映局部起伏。完成插值后，得到结构类似评分热力图的网格数据结构，如：geology.surfaceTop[row][col] = elevation，同样记录 minX, maxX, minY, maxY, resolution 及插值精度等元数据，方便查询。基于该网格，可进一步计算走向和倾角：选取采区煤层面的整体趋势（例如对整个顶板面做最小二乘平面拟合，求出倾斜方向和坡度），或者计算局部梯度场。在最简单模型下，可采用全局拟合：对所有钻孔顶板坐标点 (x,y,z) 用平面方程 z = ax + by + c 拟合，求出平面的倾角 = arctan(√(a²+b²))，倾向方位 = arctan2(b,a)（即坡度下降最快方向），走向方位则为倾向方位加90°
zhuanlan.zhihu.com
。倾角还可由插值网格中相距一定距离的两点高差来近似。例如，取网格中心点向东、西的高程差计算东西向坡度，向北、南的高程差计算南北向坡度，再综合求出最大坡度及其方向。完成这些计算后，可得到：煤层走向（方位角，例如北偏东多少度）、倾向（相对北的方向）和倾角（几度）。厚度模型则直接由钻孔煤厚做插值得到各处厚度，或由顶/底板之差计算。

**推荐代码结构/接口：**后端可新增 /api/geology 接口，对应处理地质模型请求。调用时，后端读取 store.boreholes 数据，执行建模函数生成结果并缓存在 store.geology。store.geology 可包含：surfaceTop 网格（顶板高程矩阵）、surfaceBottom 网格、thicknessGrid、以及汇总的 strike（走向方位角）、dipDirection（倾向方位角）、dipAngle（倾角）等参数。为与设计模块交互，可将关键结果传递给设计逻辑：例如在 planMainRoadway 中根据 store.geology.strike 决定主巷道走向优选方向，在坡度计算中使用 surfaceTop 提供的高程计算每段路径的坡度。
GitHub
GitHub
前端则可提供地质模型的可视化选择，如显示煤层等高线或三维剖面。此外，设计方案导出报告中也可包含地质参数，指导人工校核。代码结构上，generateGeologyModel 可以拆分为步骤：interpolateSurface(boreholes, resolution) 生成网格，fitPlane(points) 计算全局走向倾角，computeLocalSlope(surface, x,y) 计算任意点局部坡度，用于路径坡度校验。

**代码片段：**以下伪代码演示如何基于钻孔数据生成顶板高程网格，并计算煤层走向和倾角：

function generateGeologyModel(boreholes, boundary, resolution = 50) {
  // 1. 插值顶板面网格（简单IDW示例）
  const { minX, maxX, minY, maxY } = boundary; 
  const stepX = (maxX - minX) / resolution;
  const stepY = (maxY - minY) / resolution;
  let surfaceTop = Array.from({length: resolution+1}, () => Array(resolution+1).fill(null));
  for (let i = 0; i <= resolution; i++) {
    for (let j = 0; j <= resolution; j++) {
      const x = minX + j*stepX, y = minY + i*stepY;
      if (!pointInPolygon({x,y}, boundary)) continue; // 采区外跳过
      let numerator=0, denom=0;
      for (let bh of boreholes) {
        if (!bh.topElevation) continue;
        const d = Math.hypot(bh.x - x, bh.y - y) || 1e-6;
        const w = 1 / (d * d);
        numerator += w * bh.topElevation;
        denom += w;
      }
      surfaceTop[i][j] = denom ? numerator/denom : null;
    }
  }
  // 2. 计算全区拟合平面（走向倾角）
  const pts = boreholes.filter(b=>b.topElevation).map(b=>({x:b.x, y:b.y, z:b.topElevation}));
  const {a, b, c} = fitPlane(pts);  // 平面拟合，返回系数
  const dipAngle = Math.atan(Math.sqrt(a*a + b*b)) * (180/Math.PI);      // 倾角(度)
  const dipDirection = (Math.atan2(b, a) * (180/Math.PI) + 360) % 360;   // 倾向方位(0-360)
  const strike = (dipDirection + 90) % 360;  // 走向方位 = 倾向 + 90度
  return { surfaceTop, strike, dipAngle, dipDirection };
}


上述代码假定钻孔对象包含属性 topElevation（顶板标高）。首先用 IDW 方法生成了顶板高程的规则网格，接着用 fitPlane 对钻孔顶板点做平面拟合求出走向和倾角。这样得到的 strike 和 dipAngle 可用于调整工作面朝向（如令工作面长轴平行于走向方向）和巷道坡度限制（如限制巷道与倾斜方向的夹角，以控制坡度）。在将该模块集成系统时，请确保在评分计算后、设计生成前调用地质模型，以便充分利用地质参数完善设计约束。

模块四：人机协同交互设计功能

实现要点：为提高设计灵活性，可增加用户在前端手动编辑巷道和工作面的功能，实现人机协同。用户可以在热力图上直接绘制或拖拽修改设计方案：例如手动画出一条巷道线、指定一个工作面矩形的位置和大小，然后锁定这些人工指定部分，再让系统对其余部分重新自动规划优化。具体功能包括：1）手动绘制：提供绘图模式按钮，进入后用户可在画布上点击各个节点绘制折线（用于巷道）或拖动绘制矩形（用于工作面）；2）锁定调整：对用户绘制或修改的对象标记为“锁定”，后端在重新生成方案时保留这些部分不变；3）微调/重绘：允许用户拖动已生成巷道的拐点、拉伸工作面边界来微调几何形状，同时即时更新相关数值（长度、角度等）；4）协同规划：当存在锁定元素时，自动规划算法需考虑它们，例如将主巷道视为给定不变，直接在其末端规划分巷道和后续工作面，或根据用户放置的工作面区域调整周边布置。

**推荐代码结构/接口：**前端方面，在现有 Canvas 画布上添加事件监听和工具栏按钮。例如，在 MiningDesignSystem.jsx 中增加一个 “编辑模式” 按钮，切换一个状态 isEditing。当 isEditing 为真时，Canvas 的 onClick 事件改为记录点位，用以绘制用户线条；onMouseMove 时如果正在绘制则动态显示线段预览。可以在组件状态中维护 tempRoadway 或 tempWorkface 对象来存储用户当前绘制的图形。当用户结束绘制（比如双击或点击完成按钮），将该图形加入当前 designData 中，并通过 API 发送到后端保存。例如增加一个 /api/design/manual 或在原有 /api/design POST 中识别传入的 userEdits 字段，其中包含用户自定义的巷道/工作面几何。后端收到后，将这些固定元素并入设计：可以在 planMainRoadway 开始时检查如果请求中附带了 fixedMainPath，则跳过算法直接使用之；或在 planWorkfaces 中先将 fixedWorkfaces 从用户输入纳入结果，然后对剩余高分区域做补充规划。锁定的元素可通过一个布尔属性或单独的列表传递。后端在生成方案时应保护锁定元素，例如不重复生成相同位置的工作面，也避免主巷道规划再经过已由用户指定的路径。实现上，后端 store 可增加 store.manualDesign 或将 store.design 拆分为 userDesign 与 autoDesign 两部分，在最终响应前合并。
GitHub
GitHub
前端在绘制时需区分自动和手动部分，锁定的内容可用不同样式显示（例如不同颜色边框表示用户定义区域）。同时提供“重算设计”按钮，调用 /api/design 时附上用户锁定内容，让后端据此重新计算未锁定部分的最优方案，并返回更新的整体设计。

**代码片段：**以下示例展示了如何在前端捕获用户绘制巷道路径，以及后端融合用户路径：

// 前端：Canvas 添加点击绘制巷道路径
<canvas ref={canvasRef} 
        onMouseDown={(e) => {
          if (!isEditing) return;
          const rect = e.target.getBoundingClientRect();
          const x = (e.clientX - rect.left) / scale - panOffset.x;
          const y = (e.clientY - rect.top) / scale - panOffset.y;
          setTempRoad(prev => prev ? {...prev, path: [...prev.path, {x, y}]} 
                                   : { id: 'UserPath1', path: [{x,y}] });
        }} 
        onMouseMove={(e) => {
          // 动态预览线条略
        }} />
// 后端：在 planMainRoadway 中融合用户指定主巷道
function planMainRoadway(grid, boundary, regions, minScore, userMainPath) {
  if (userMainPath) {
    // 直接计算用户路径的长度和平均分并返回
    const path = userMainPath;
    const length = calculatePathLength(path);
    const avgScore = calculateAvgScoreAlongPath(grid, path);
    return { path, length: Math.round(length), avgScore: Math.round(avgScore*10)/10 };
  }
  // ...否则执行原有自动规划逻辑:contentReference[oaicite:18]{index=18}...
}


上述前端代码在编辑模式下，捕获鼠标点击将坐标转换为与画布一致的设计坐标（考虑了缩放和平移），逐点构建一条用户路径。后端代码片段展示了如果检测到用户提供了 userMainPath，则跳过自动算法，直接利用该路径计算长度和评分
GitHub
作为主巷道返回。而对于没有用户干预的情况，则执行原逻辑生成。
GitHub
同理，planWorkfaces 和 planBranchRoadways 也可增加对用户锁定工作面和分巷道的处理：例如用户提供了特定工作面多边形列表，则在自动划分时优先保留这些，并避免在相邻过近区域重复布置。通过这样的机制，系统可以实现在自动设计与人工修改之间迭代：算法提供初步方案→用户调整部分方案→算法根据调整优化剩余部分。这将极大提高系统实用性，使最终设计更符合现场要求和工程师经验。

模块集成与优化建议

上述各模块应当集成到现有系统的前后端架构中。后端方面，新增的地质模型计算和改进的路径规划可作为 utils 工具函数调用，在 /api/design 中先获取必要的地质信息再进行规划。
GitHub
GitHub
前端方面，新增的人机交互工具应与现有状态管理兼容，例如在 designData 中合并用户编辑内容，并提供导出报告时将所有信息（包括锁定标记）输出。开发者可按照模块功能逐步优化：先替换路径规划算法，验证规程约束效果；再调整数据结构和接口，保证前后端数据一致；随后加入地质模型，提高规划科学性；最后实现前端交互优化用户体验。通过以上步骤，煤矿巷道与工作面布局规程将融入系统，实现更专业可信的采掘设计方案。各模块关键代码引用和建议如上，开发者可据此按图索骥逐步改进。
