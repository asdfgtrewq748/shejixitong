我直接给你一套**可落地的实现方案 + 修改步骤**，默认你现在是用 JS/TS 在做一个「对单个网格点打分」的函数（比如 `scoreFormulas.ts` 之类）。你可以按下面步骤一点点改。

---

## 一、整体思路（确保和你现在的架构兼容）

假设你现在有类似的接口：

```ts
export interface PointFeatures {
  // 已有字段（举例）
  depth: number;          // 埋深 m
  coalThickness: number;  // 煤层厚度 m
  rockHardness: number;   // 普氏系数 1~10

  // === 新增/整理字段（环保相关） ===
  aquiferPressure?: number;      // 含水层水压 MPa（可选）
  aquicludeThickness?: number;   // 隔水层厚度 m（可选）
  waterRichnessIndex?: number;   // 富水指数 0~1，越大越富水
  ecoLandType: 'reserve' | 'forest' | 'farmland' | 'grassland' | 'construction' | 'wasteland';
  distanceToWaterBody: number;   // 距最近河流/湖泊 m
  distanceToProtectedArea: number; // 距生态保护区 m

  // === 新增/整理字段（经济相关） ===
  distanceToBoundary: number;    // 距采区边界最近距离 m
  calorificValue: number;        // 发热量 MJ/kg
}

export interface GlobalContext {
  // 全局/区域级参数（初始化时算好）
  idealCoalThickness: number;    // 理想厚度，比如 6 m
  maxLocalReserveRadius: number; // 认为“储量很充分”的半径，比如 200 m
  calorificMin: number;          // 矿区煤质最差热值
  calorificMax: number;          // 矿区煤质最好热值
}
```

然后对每个网格点有一个统一入口：

```ts
export function computeScores(
  point: PointFeatures,
  ctx: GlobalContext
): { safety: number; env: number; economic: number } {
  const env = computeEnvScore(point);
  const economic = computeEconomicScore(point, ctx);
  const safety = 0; // 你后面再接上自己的安全算法

  return { safety, env, economic };
}
```

下面重点就是把 `computeEnvScore` 和 `computeEconomicScore` 的实现补上。

---

## 二、工具函数（统一做 0–100 限制）

先写几个小工具，防止分数跑出 0–100：

```ts
function clamp(min: number, max: number, v: number): number {
  return Math.max(min, Math.min(max, v));
}

function clampScore(v: number): number {
  return clamp(0, 100, v);
}

/** 避免除以 0 */
function safeDiv(num: number, den: number, fallback = 0): number {
  if (!den || !isFinite(den)) return fallback;
  return num / den;
}
```

---

## 三、环保评分实现：`computeEnvScore`

### 1. 地表沉陷风险评分

公式思路：

* `R = coalThickness / depth`，越大表示沉陷风险越高
* 评分 = `100 - K * R * 100`，再截断到 0–100
* 再乘一个岩石硬度修正因子（硬度 7 最佳）

```ts
function scoreSurfaceSubsidence(point: PointFeatures): number {
  const { depth, coalThickness, rockHardness } = point;

  if (depth <= 0 || coalThickness <= 0) {
    // 没有开采或数据异常，当作无沉陷风险
    return 100;
  }

  const r = coalThickness / depth; // 厚度/埋深
  const K = 5; // 调节系数，后期可调：r=0.05 -> 扣 25 分

  let score = 100 - K * r * 100; // 例如：score = 100 - 500*r
  score = clampScore(score);

  // 岩石硬度修正（7 为理想硬度）
  const hardnessTarget = 7;
  const hardnessFactor = clamp(0.5, 1.2, rockHardness / hardnessTarget);
  score = clampScore(score * hardnessFactor);

  return score;
}
```

### 2. 含水层扰动 / 水灾风险评分

优先用突水系数 `T = P / M`，再按 0.1 MPa/m 阈值算分；
如果没有水压/隔水层厚度，就退化成用 `waterRichnessIndex` 简单扣分。

```ts
function scoreWaterHazard(point: PointFeatures): number {
  const { aquiferPressure, aquicludeThickness, waterRichnessIndex = 0 } = point;

  // 优先用突水系数（有真实数据时）
  if (aquiferPressure != null && aquicludeThickness != null && aquicludeThickness > 0) {
    const T = aquiferPressure / aquicludeThickness; // MPa/m
    const Tcrit = 0.1; // 风险阈值

    if (T >= Tcrit) {
      return 0;
    } else {
      // T 越接近 0 越安全，T=0 -> 100，T=Tcrit -> 0
      const score = 100 * (Tcrit - T) / Tcrit;
      return clampScore(score);
    }
  }

  // 否则用富水指数 0~1：越富水风险越高
  // 富水 0 -> 100 分，富水 1 -> 0 分
  const score = 100 * (1 - clamp(0, 1, waterRichnessIndex));
  return clampScore(score);
}
```

### 3. 生态破坏评分

思路：

* 先按土地利用类型给一个基础分（荒地最高、保护区最低）；
* 再根据距离水体/保护区做惩罚（越近惩罚越大）。

```ts
function baseEcoScoreByLandType(land: PointFeatures['ecoLandType']): number {
  switch (land) {
    case 'reserve': return 5;   // 保护区，本身生态价值极高，开采很敏感
    case 'forest': return 20;
    case 'farmland': return 40;
    case 'grassland': return 60;
    case 'construction': return 80;
    case 'wasteland': return 100;
    default: return 60;
  }
}

function scoreEcoImpact(point: PointFeatures): number {
  let score = baseEcoScoreByLandType(point.ecoLandType);

  // 距水体惩罚：200 m 内线性减半
  const waterSafeDist = 200;
  if (point.distanceToWaterBody < waterSafeDist) {
    const factor = point.distanceToWaterBody / waterSafeDist; // 0~1
    score *= clamp(0, 1, factor); // 越近越减分
  }

  // 距保护区惩罚：500 m 内线性减半
  const protectedSafeDist = 500;
  if (point.distanceToProtectedArea < protectedSafeDist) {
    const factor = point.distanceToProtectedArea / protectedSafeDist;
    score *= clamp(0, 1, factor);
  }

  return clampScore(score);
}
```

### 4. 环保总分汇总

```ts
function computeEnvScore(point: PointFeatures): number {
  const sSubs = scoreSurfaceSubsidence(point);
  const sWater = scoreWaterHazard(point);
  const sEco = scoreEcoImpact(point);

  // 权重：沉陷 0.4，水害 0.3，生态 0.3
  const envScore =
    0.4 * sSubs +
    0.3 * sWater +
    0.3 * sEco;

  return clampScore(envScore);
}
```

---

## 四、经济评分实现：`computeEconomicScore`

### 1. 可采储量评分（用距边界近似）

真正按窗口体积算很麻烦，可以先用一个**“离边界越远储量越充足”**的近似：

* 距离大于某个阈值 `maxLocalReserveRadius` → 视为“储量充分”，得 100
* 距离=0 → 得 0，线性插值

```ts
function scoreLocalReserve(point: PointFeatures, ctx: GlobalContext): number {
  const { distanceToBoundary } = point;
  const R = ctx.maxLocalReserveRadius; // 比如 200 m

  const ratio = clamp(0, 1, distanceToBoundary / R);
  const score = 100 * ratio; // 越靠中部分越高
  return clampScore(score);
}
```

> 以后你可以把这个函数替换成：用局部窗口（比如 200 m）内平均厚度 × 面积来算近似储量，再和全区最大值归一化。

### 2. 煤层厚度评分

* 设置一个理想厚度 `idealCoalThickness`（比如 6 m）；
* 厚度 ≥ 理想厚度 → 100 分；
* 厚度越少，分数以幂函数下降（比线性更温和）。

```ts
function scoreCoalThickness(point: PointFeatures, ctx: GlobalContext): number {
  const { coalThickness } = point;
  const ideal = ctx.idealCoalThickness || 6;

  if (coalThickness <= 0) return 0;

  let ratio = coalThickness / ideal;
  if (ratio >= 1) return 100;

  // 幂指数 <1，使得前期增加更有收益，后期边际变小
  const gamma = 0.7;
  const score = 100 * Math.pow(ratio, gamma);

  return clampScore(score);
}
```

### 3. 煤质评分

* 用热值对区间 `[calorificMin, calorificMax]` 做归一化；
* 超出区间的按边界处理。

```ts
function scoreCoalQuality(point: PointFeatures, ctx: GlobalContext): number {
  const { calorificValue } = point;
  const { calorificMin, calorificMax } = ctx;

  if (!isFinite(calorificValue) || calorificMax <= calorificMin) {
    // 没有正确数据，就给一个中间分
    return 50;
  }

  let norm = (calorificValue - calorificMin) / (calorificMax - calorificMin);
  norm = clamp(0, 1, norm);

  const score = 100 * norm;
  return clampScore(score);
}
```

### 4. 经济总分汇总

```ts
function computeEconomicScore(point: PointFeatures, ctx: GlobalContext): number {
  const sReserve = scoreLocalReserve(point, ctx);
  const sThick = scoreCoalThickness(point, ctx);
  const sQuality = scoreCoalQuality(point, ctx);

  const econScore =
    0.33 * sReserve +
    0.33 * sThick +
    0.34 * sQuality;

  return clampScore(econScore);
}
```

---

## 五、具体修改步骤指南（你可以照着做）

我按“最小侵入式改造”的思路写一个 checklist：

### 步骤 1：扩展你的点数据结构

1. 在你项目里描述地质插值结果的类型/接口上，加上：

   * `aquiferPressure?`
   * `aquicludeThickness?`
   * `waterRichnessIndex?`
   * `ecoLandType`
   * `distanceToWaterBody`
   * `distanceToProtectedArea`
   * `distanceToBoundary`
   * `calorificValue`
2. 先不用所有字段都填满：

   * 没有水压就只填 `waterRichnessIndex`；
   * 没有煤质就先用一个统一的值（比如全区平均热值），后面再细化。

### 步骤 2：增加一个全局上下文配置

在你程序初始化阶段（比如加载完钻孔数据后）：

```ts
const globalContext: GlobalContext = {
  idealCoalThickness: 6,           // 你可以改成 12 号煤的典型厚度
  maxLocalReserveRadius: 200,      // 采区边界 200 m 内开始衰减
  calorificMin: 18,                // 根据实验数据填
  calorificMax: 30
};
```

### 步骤 3：把现有的“环保分 / 经济分”函数替换成上面的

假设你原来有：

```ts
export function computeEnvScoreOld(point: OldPoint): number { ... }
export function computeEconomicScoreOld(point: OldPoint): number { ... }
```

现在：

1. 新建一个文件 `envEconomicScores.ts`，把我上面的代码粘进去；
2. 在你总评分函数里：

```ts
import { computeEnvScore, computeEconomicScore } from './envEconomicScores';

export function computeScores(point: PointFeatures): Scores {
  const env = computeEnvScore(point);
  const economic = computeEconomicScore(point, globalContext);
  const safety = computeSafetyScore(point); // 你自己的

  return { safety, env, economic };
}
```

### 步骤 4：检查可视化/前端是否需要适配

1. 如果前端只是画热力图，只要你继续输出 0–100 分，它不需要改；
2. 如果前端有 tooltip 显示“环保分 = xx（由地下水 + 生态 + 沉陷综合得到）”，可以：

   * 在接口里再返回子项：`envSubsidence`, `envWater`, `envEco`；
   * 用于前端展示更细节的解释（方便后期你写论文时截图）。

### 步骤 5：调参 + 校验

1. 先用你熟悉的一两个采区做对比，看看：

   * 你直觉上“不想开”的区域，环保/经济分是不是确实偏低？
   * 你觉得“很适合布置巷道、布置工作面”的区域，分数是不是偏高？
2. 根据实际感觉调整：

   * `K`（沉陷评分扣分系数）；
   * `waterSafeDist`、`protectedSafeDist`；
   * `maxLocalReserveRadius`、`idealCoalThickness`；
   * 三大子项权重（0.4/0.3/0.3、0.33/0.33/0.34 等）。

---

