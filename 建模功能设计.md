<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoCore - 史诗级地质建模系统</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #020408;
            color: #e0e0e0;
            font-family: 'Rajdhani', sans-serif;
        }

        h1, h2, h3, .brand-font {
            font-family: 'Orbitron', sans-serif;
        }

        /* 极简滚动条 */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        ::-webkit-scrollbar-thumb { background: #00ffff; border-radius: 2px; }

        /* 高级玻璃拟态面板 */
        .glass-panel {
            background: rgba(8, 12, 20, 0.65);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(0, 255, 255, 0.08);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
        }

        /* 选中态特效 */
        .active-layer-btn {
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.2) 0%, transparent 100%);
            border-left: 3px solid #00ffff;
            color: #fff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        /* 全屏网格背景 - 更加深邃 */
        #blueprintCanvas {
            background-color: #050608;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(rgba(0, 255, 255, 0.02) 2px, transparent 2px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.02) 2px, transparent 2px);
            background-size: 100px 100px, 100px 100px, 20px 20px, 20px 20px;
            cursor: crosshair;
        }

        /* 扫描线动画 */
        .scanline {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to bottom, transparent 50%, rgba(0, 255, 255, 0.02) 51%, transparent 51%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 5;
        }

        /* 呼吸灯 */
        .blink-red { animation: blinker-red 2s infinite; }
        @keyframes blinker-red { 50% { opacity: 0.3; } }

        .tech-border-corner {
            position: absolute;
            width: 10px; height: 10px;
            border-color: #00ffff;
            border-style: solid;
            transition: all 0.3s ease;
        }
        .tl { top: -1px; left: -1px; border-width: 2px 0 0 2px; }
        .tr { top: -1px; right: -1px; border-width: 2px 2px 0 0; }
        .bl { bottom: -1px; left: -1px; border-width: 0 0 2px 2px; }
        .br { bottom: -1px; right: -1px; border-width: 0 2px 2px 0; }
        
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px; width: 12px;
            background: #00ffff;
            border-radius: 50%;
            margin-top: -4px;
            box-shadow: 0 0 10px #00ffff;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden select-none">

    <!-- 全屏 2D 绘图区 (底层) -->
    <div class="absolute inset-0 z-0">
        <canvas id="blueprintCanvas" class="w-full h-full"></canvas>
        <div class="scanline"></div>
        
        <!-- 装饰性坐标 -->
        <div class="absolute top-1/2 left-0 w-full h-[1px] bg-cyan-900/30 pointer-events-none"></div>
        <div class="absolute top-0 left-1/2 w-[1px] h-full bg-cyan-900/30 pointer-events-none"></div>
        
        <!-- 底部信息 -->
        <div class="absolute bottom-6 left-8 text-cyan-600/50 font-mono text-xs pointer-events-none">
            COORDINATES: <span id="coordDisplay" class="text-cyan-400">X:0000 Y:0000</span> | ZOOM: 100% | GRID: 20M
        </div>
    </div>

    <!-- 左上角：主标题与工具栏 -->
    <div class="absolute top-6 left-8 z-30 flex flex-col gap-6 w-80 pointer-events-none">
        <!-- 标题 -->
        <div>
            <div class="flex items-center gap-3 mb-1">
                <div class="w-2 h-8 bg-cyan-500 shadow-[0_0_15px_#00ffff]"></div>
                <h1 class="text-4xl font-black italic tracking-widest text-white drop-shadow-[0_0_10px_rgba(0,255,255,0.5)]">GEO<span class="text-cyan-400">CORE</span></h1>
            </div>
            <div class="text-xs text-cyan-500/70 tracking-[0.3em] pl-5">TUNNEL ENGINEERING SUITE</div>
        </div>

        <!-- 2D 工具箱 -->
        <div class="glass-panel p-4 rounded-lg pointer-events-auto border-l-4 border-l-cyan-500/50">
            <h3 class="text-cyan-400 font-bold mb-2 text-sm uppercase tracking-wider flex justify-between">
                <span>Drawing Tools</span>
                <span class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
            </h3>
            <p class="text-xs text-gray-400 mb-4 leading-relaxed">
                在主视图中绘制隧道路径。系统将自动同步至地质模型。
            </p>
            <div class="grid grid-cols-2 gap-2">
                <button onclick="undoPoint()" class="py-2 bg-gray-800 hover:bg-gray-700 border border-gray-600 rounded text-xs text-gray-300 transition hover:text-white hover:border-cyan-500">
                    撤销节点 (UNDO)
                </button>
                <button onclick="clearCanvas()" class="py-2 bg-red-900/20 hover:bg-red-900/40 border border-red-900/50 rounded text-xs text-red-400 transition hover:text-red-300 hover:border-red-500">
                    清空画布 (CLR)
                </button>
            </div>
        </div>
    </div>

    <!-- 右上角：3D 悬浮监视器 (HUD) -->
    <div class="absolute top-6 right-6 z-40 w-[420px] flex flex-col gap-2 pointer-events-none">
        
        <!-- 3D 视窗容器 -->
        <div class="relative w-full h-[320px] glass-panel pointer-events-auto group bg-black/40">
            <!-- 装饰性角标 -->
            <div class="tech-border-corner tl"></div>
            <div class="tech-border-corner tr"></div>
            <div class="tech-border-corner bl"></div>
            <div class="tech-border-corner br"></div>
            
            <!-- 顶部状态栏 -->
            <div class="absolute top-3 left-4 right-4 flex justify-between items-center z-10 text-[10px] font-bold tracking-widest text-cyan-500/80">
                <span>LIVE PREVIEW</span>
                <div class="flex items-center gap-2">
                    <span class="w-1.5 h-1.5 bg-red-500 rounded-full blink-red"></span>
                    <span class="text-red-500/80">REC</span>
                </div>
            </div>

            <!-- 3D Canvas -->
            <div id="canvas-container" class="w-full h-full cursor-move"></div>
            
            <!-- 底部图层指示 -->
            <div class="absolute bottom-0 left-0 w-full h-8 bg-gradient-to-t from-black/80 to-transparent pointer-events-none"></div>
            <div class="absolute bottom-2 left-4 text-xs font-mono text-white/80 drop-shadow-md pointer-events-none">
                CURRENT LAYER: <span id="hudLayerName" class="text-cyan-400 font-bold">INIT...</span>
            </div>
        </div>

        <!-- 控制面板 (紧凑型) -->
        <div class="glass-panel p-0 rounded-lg overflow-hidden pointer-events-auto flex flex-col">
            <!-- 选项卡/头部 -->
            <div class="px-4 py-3 border-b border-white/5 bg-white/5 flex justify-between items-center">
                <h3 class="text-sm font-bold text-gray-200">地质分层数据</h3>
                <div class="flex gap-2">
                    <button class="w-4 h-4 rounded-full border border-gray-500 hover:bg-cyan-500/50 transition"></button>
                    <button class="w-4 h-4 rounded-full border border-gray-500 hover:bg-cyan-500/50 transition"></button>
                </div>
            </div>

            <div class="flex h-48">
                <!-- 左侧列表 -->
                <div id="layerList" class="w-2/3 overflow-y-auto border-r border-white/5 p-1">
                    <!-- JS 生成列表 -->
                </div>
                
                <!-- 右侧滑块控制 -->
                <div class="w-1/3 p-3 flex flex-col justify-center gap-4 bg-black/20">
                    <div class="space-y-1">
                        <label class="text-[10px] text-gray-500 uppercase">Opacity</label>
                        <input type="range" id="opacitySlider" min="0.1" max="1" step="0.1" value="0.4" class="w-full">
                    </div>
                    <div class="space-y-1">
                        <label class="text-[10px] text-gray-500 uppercase">Wireframe</label>
                        <div class="flex items-center gap-2 cursor-pointer" onclick="document.getElementById('wireframeToggle').click()">
                            <input type="checkbox" id="wireframeToggle" class="accent-cyan-500 w-3 h-3">
                            <span class="text-xs text-gray-400">Enable</span>
                        </div>
                    </div>
                    <div class="space-y-1">
                        <label class="text-[10px] text-gray-500 uppercase">Auto-Spin</label>
                        <div class="flex items-center gap-2 cursor-pointer" onclick="document.getElementById('rotateToggle').click()">
                            <input type="checkbox" id="rotateToggle" class="accent-cyan-500 w-3 h-3">
                            <span class="text-xs text-gray-400">On</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 交互逻辑 -->
    <script>
        // ================= 数据定义 =================
        const LAYERS = [
            { id: 0, name: "表层土壤 (TOPSOIL)", color: 0x8B4513, height: 1, depth: 2 },
            { id: 1, name: "砂砾层 (GRAVEL)", color: 0xE6C229, height: 2, depth: 3 },
            { id: 2, name: "粘土层 (CLAY)", color: 0xA0522D, height: 3, depth: 4 }, // 默认选中
            { id: 3, name: "软岩层 (SOFT ROCK)", color: 0x708090, height: 4, depth: 4 },
            { id: 4, name: "基岩 (BEDROCK)", color: 0x2F4F4F, height: 4, depth: 6 }
        ];

        let state = {
            selectedLayerIndex: 2,
            points2D: [],
            isDrawing: false,
            scale: 20,
            globalOpacity: 0.4
        };

        // ================= 3D 引擎 (THREE.JS) =================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // 背景透明
        
        // 相机调整：因为窗口变小了，我们需要更广的视角或者调整距离
        const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(30, 25, 30);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // 灯光系统优化
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xaaccff, 1.2);
        dirLight.position.set(20, 40, 20);
        scene.add(dirLight);

        const blueBackLight = new THREE.PointLight(0x00ffff, 0.8, 100);
        blueBackLight.position.set(-20, 10, -20);
        scene.add(blueBackLight);

        // 控制器
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let autoRotate = false;

        container.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('mouseleave', () => isDragging = false); // 防止拖出框外卡住

        container.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                
                const rotSpeed = 0.008;
                const radius = Math.sqrt(camera.position.x ** 2 + camera.position.z ** 2);
                const angle = Math.atan2(camera.position.z, camera.position.x);
                const newAngle = angle - deltaMove.x * rotSpeed;
                
                camera.position.x = radius * Math.cos(newAngle);
                camera.position.z = radius * Math.sin(newAngle);
                camera.position.y += deltaMove.y * 0.2;
                camera.lookAt(0, 0, 0);

                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const fov = camera.fov + e.deltaY * 0.05;
            camera.fov = THREE.MathUtils.clamp(fov, 20, 90);
            camera.updateProjectionMatrix();
        });

        // 构建地质层
        const layersGroup = new THREE.Group();
        const layerMeshes = [];
        const layerHighlights = [];

        let currentY = 0;
        const totalHeight = LAYERS.reduce((acc, l) => acc + l.depth, 0);
        const startY = totalHeight / 2;

        LAYERS.forEach((layerData, index) => {
            const geometry = new THREE.BoxGeometry(state.scale, layerData.depth, state.scale);
            
            const material = new THREE.MeshPhysicalMaterial({
                color: layerData.color,
                transparent: true,
                opacity: state.globalOpacity,
                roughness: 0.2,
                metalness: 0.1,
                clearcoat: 0.8,
                side: THREE.DoubleSide
            });

            const mesh = new THREE.Mesh(geometry, material);
            const yPos = -startY + currentY + (layerData.depth / 2);
            mesh.position.y = yPos;
            mesh.userData = { id: index, type: 'layer' };

            // 装饰性边缘
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });
            const wireframe = new THREE.LineSegments(edges, lineMat);
            mesh.add(wireframe);

            // 高亮框
            const highlightGeo = new THREE.BoxGeometry(state.scale + 0.1, layerData.depth + 0.1, state.scale + 0.1);
            const highlightMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.0 
            });
            const highlightMesh = new THREE.Mesh(highlightGeo, highlightMat);
            highlightMesh.position.y = yPos;
            highlightMesh.visible = false;
            
            layerMeshes.push(mesh);
            layerHighlights.push(highlightMesh);
            layersGroup.add(mesh);
            scene.add(highlightMesh);

            currentY += layerData.depth;
        });

        scene.add(layersGroup);
        const tunnelGroup = new THREE.Group();
        scene.add(tunnelGroup);

        // 底部网格装饰
        const gridHelper = new THREE.GridHelper(state.scale * 2.5, 25, 0x00ffff, 0x111111);
        gridHelper.position.y = -startY - 2;
        gridHelper.material.opacity = 0.2;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);


        // ================= 2D 设计器 (全屏 Canvas) =================
        const canvas = document.getElementById('blueprintCanvas');
        const ctx = canvas.getContext('2d');
        const coordDisplay = document.getElementById('coordDisplay');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawBlueprint();
            
            // 同时更新3D视窗大小（防止窗口拉伸时3D变形）
            const rect = container.getBoundingClientRect();
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
            renderer.setSize(rect.width, rect.height);
        }
        window.addEventListener('resize', resizeCanvas);

        function drawBlueprint() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制中心十字线 (HUD风格)
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, 0);
            ctx.lineTo(canvas.width/2, canvas.height);
            ctx.moveTo(0, canvas.height/2);
            ctx.lineTo(canvas.width, canvas.height/2);
            ctx.stroke();

            // 绘制路径
            if (state.points2D.length > 0) {
                // 发光效果
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ffff';
                
                // 线条
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(state.points2D[0].x, state.points2D[0].y);
                for (let i = 1; i < state.points2D.length; i++) {
                   ctx.lineTo(state.points2D[i].x, state.points2D[i].y);
                }
                ctx.stroke();

                // 节点
                ctx.fillStyle = '#000';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                state.points2D.forEach((p, i) => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                });
                ctx.shadowBlur = 0;
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            state.points2D.push({x: e.clientX, y: e.clientY});
            drawBlueprint();
            update3DTunnel();
        });

        canvas.addEventListener('mousemove', (e) => {
            coordDisplay.innerHTML = `X:${e.clientX.toString().padStart(4,'0')} Y:${e.clientY.toString().padStart(4,'0')}`;
        });

        function clearCanvas() {
            state.points2D = [];
            drawBlueprint();
            update3DTunnel();
        }

        function undoPoint() {
            state.points2D.pop();
            drawBlueprint();
            update3DTunnel();
        }

        // ================= 坐标映射逻辑 =================
        function update3DTunnel() {
            while(tunnelGroup.children.length > 0) tunnelGroup.remove(tunnelGroup.children[0]);
            if (state.points2D.length < 2) return;

            const activeLayerMesh = layerMeshes[state.selectedLayerIndex];
            const yLevel = activeLayerMesh.position.y;

            // 映射算法：将全屏 Canvas 映射到 3D 模型的范围 (-10 ~ 10)
            // 保持比例还是拉伸？这里选择简单的拉伸映射，保证覆盖全模
            const points3D = state.points2D.map(p => {
                const xPct = p.x / canvas.width;
                const yPct = p.y / canvas.height; 

                // 映射到 -scale/2 到 +scale/2
                const x3d = (xPct * state.scale) - (state.scale / 2);
                const z3d = (yPct * state.scale) - (state.scale / 2); 
                
                return new THREE.Vector3(x3d, yLevel, z3d);
            });

            const curve = new THREE.CatmullRomCurve3(points3D);
            const tubeGeometry = new THREE.TubeGeometry(curve, points3D.length * 8, 0.35, 8, false);
            
            const tubeMaterial = new THREE.MeshPhongMaterial({
                color: 0xff00cc,
                emissive: 0xff0055,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.9
            });

            const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tunnelGroup.add(tubeMesh);

            // 全息光环特效
            const count = Math.min(Math.floor(curve.getLength()), 15); // 限制光环数量
            for(let i=0; i<=count; i++) {
                const t = i/count;
                const pos = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t);
                
                const ringGeo = new THREE.TorusGeometry(0.5, 0.03, 8, 16);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                
                ring.position.copy(pos);
                ring.lookAt(pos.clone().add(tangent));
                tunnelGroup.add(ring);
            }
        }

        // ================= UI 逻辑 =================
        const layerListEl = document.getElementById('layerList');
        const hudLayerName = document.getElementById('hudLayerName');

        function selectLayer(index) {
            state.selectedLayerIndex = index;
            hudLayerName.innerText = LAYERS[index].name;

            document.querySelectorAll('.layer-item').forEach(el => {
                el.classList.remove('active-layer-btn');
                el.style.background = 'transparent';
                if (parseInt(el.dataset.id) === index) {
                    el.classList.add('active-layer-btn');
                }
            });

            layerHighlights.forEach((h, i) => h.visible = (i === index));
            
            layerMeshes.forEach((m, i) => {
                // 停止可能存在的旧动画，防止冲突
                gsap.killTweensOf(m.material);
                // 注意：由于我们将对代理对象进行 tween，这里需要特别小心。
                // 简单的做法是，如果正在选中或取消选中，我们都重新开始动画。

                if (i === index) {
                    // 目标颜色
                    const targetColor = new THREE.Color(LAYERS[i].color);
                    const initialColor = m.material.color.clone(); // 克隆当前颜色作为起点
                    
                    // 使用代理对象来驱动颜色变化，避免直接操作 Three.js Color 属性引发的 WebGL 上传错误
                    const colorProxy = { r: initialColor.r, g: initialColor.g, b: initialColor.b };
                    
                    gsap.to(colorProxy, { 
                        r: targetColor.r, 
                        g: targetColor.g, 
                        b: targetColor.b, 
                        duration: 0.4,
                        onUpdate: () => {
                            m.material.color.setRGB(colorProxy.r, colorProxy.g, colorProxy.b);
                        }
                    });
                    
                    gsap.to(m.material, { 
                        opacity: Math.min(state.globalOpacity + 0.3, 0.9), 
                        duration: 0.4 
                    });
                } else {
                    // 变暗颜色
                    const dimColor = new THREE.Color(0x333333);
                    const initialColor = m.material.color.clone();
                    
                    const colorProxy = { r: initialColor.r, g: initialColor.g, b: initialColor.b };
                    
                    gsap.to(colorProxy, { 
                        r: dimColor.r, 
                        g: dimColor.g, 
                        b: dimColor.b, 
                        duration: 0.4,
                        onUpdate: () => {
                            m.material.color.setRGB(colorProxy.r, colorProxy.g, colorProxy.b);
                        }
                    });
                    
                    gsap.to(m.material, { 
                        opacity: 0.1, 
                        duration: 0.4 
                    });
                }
            });

            update3DTunnel();
        }

        LAYERS.forEach((layer, idx) => {
            const div = document.createElement('div');
            div.className = `layer-item p-2 mb-1 rounded cursor-pointer hover:bg-white/10 transition text-xs border-l-2 border-transparent`;
            div.dataset.id = idx;
            div.innerHTML = `
                <div class="font-bold text-gray-300 truncate">${layer.name}</div>
                <div class="text-[9px] text-gray-500">DEPTH: ${layer.depth}M</div>
            `;
            div.onclick = () => selectLayer(idx);
            layerListEl.prepend(div);
        });

        document.getElementById('opacitySlider').addEventListener('input', (e) => {
            state.globalOpacity = parseFloat(e.target.value);
            selectLayer(state.selectedLayerIndex); // 刷新当前状态
        });

        document.getElementById('wireframeToggle').addEventListener('change', (e) => {
            layerMeshes.forEach(m => m.material.wireframe = e.target.checked);
        });
        
        document.getElementById('rotateToggle').addEventListener('change', (e) => {
            autoRotate = e.target.checked;
        });

        // 3D 拾取 (双击模型)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        container.addEventListener('dblclick', (e) => {
            const rect = container.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(layerMeshes);

            if (intersects.length > 0) {
                selectLayer(intersects[0].object.userData.id);
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            if(autoRotate) {
                const angle = 0.005;
                const radius = Math.sqrt(camera.position.x ** 2 + camera.position.z ** 2);
                const currAngle = Math.atan2(camera.position.z, camera.position.x);
                camera.position.x = radius * Math.cos(currAngle + angle);
                camera.position.z = radius * Math.sin(currAngle + angle);
                camera.lookAt(0, 0, 0);
            }
            
            // 隧道光环动画
            tunnelGroup.children.forEach(c => {
                 if(c.geometry.type === 'TorusGeometry') c.rotation.z += 0.05;
            });

            layerHighlights.forEach(h => {
                if(h.visible) h.material.opacity = 0.5 + Math.sin(Date.now() * 0.005) * 0.3;
            });

            renderer.render(scene, camera);
        }

        setTimeout(() => {
            resizeCanvas();
            selectLayer(2);
            animate();
        }, 100);

    </script>
</body>
</html>